<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Block World</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: none; /* Hide default cursor */
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows mouse events to pass through */
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-top: -10px;
            margin-left: -10px;
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 0 5px white;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            backdrop-filter: blur(5px);
            pointer-events: auto; /* Enable mouse events */
        }

        #hunger-bar {
            width: 200px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            border-radius: 5px;
            overflow: hidden;
        }

        #hunger-fill {
            height: 100%;
            background-color: orange;
            transition: width 0.2s;
        }

        .button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px 2px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.1s;
        }

        .button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }

        .button:active {
            transform: scale(0.95);
        }

        #status-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            opacity: 0;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            pointer-events: auto;
            z-index: 1000;
        }

        #message-box h3 {
            margin-top: 0;
            color: #4CAF50;
        }

        #message-box p {
            margin-bottom: 20px;
        }

        #user-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
        }

        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>

    <div id="game-container">
        <div id="ui">
            <div id="crosshair"></div>
            <div id="hud">
                <p>Hunger</p>
                <div id="hunger-bar"><div id="hunger-fill"></div></div>
            </div>
            <div id="user-info">
                User ID: <span id="user-id">Loading...</span>
            </div>
        </div>
    </div>
    <div id="status-message"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase debug level
        setLogLevel('debug');

        // Firestore and Auth setup
        let firebaseApp, db, auth;
        let userId;

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let worldDataRef;

        async function initFirebase() {
            try {
                if (firebaseConfig) {
                    firebaseApp = initializeApp(firebaseConfig);
                    db = getFirestore(firebaseApp);
                    auth = getAuth(firebaseApp);

                    await new Promise(resolve => {
                        onAuthStateChanged(auth, async (user) => {
                            if (!user) {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(auth, initialAuthToken);
                                } else {
                                    await signInAnonymously(auth);
                                }
                            }
                            userId = auth.currentUser?.uid || crypto.randomUUID();
                            worldDataRef = doc(db, 'artifacts', appId, 'users', userId, 'world', 'player_world');
                            document.getElementById('user-id').textContent = userId;
                            console.log("Firebase initialized. User ID:", userId);
                            resolve();
                        });
                    });
                } else {
                    console.error("Firebase config not available. Skipping database features.");
                    document.getElementById('user-id').textContent = 'No DB';
                }
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                document.getElementById('user-id').textContent = 'Error';
            }
        }

        // Game state variables
        let scene, camera, renderer;
        let controls;
        let hunger = 100;
        let hungerInterval;
        let world = [];
        const worldSize = 32;
        const blockSize = 1;
        const playerSpeed = 0.05;
        const hungerDrainRate = 0.1;

        // UI elements
        const hungerFill = document.getElementById('hunger-fill');
        const statusMessage = document.getElementById('status-message');
        const loadingScreen = document.getElementById('loading-screen');
        const gameContainer = document.getElementById('game-container');

        const blocks = {
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x654321 }),
            grass: new THREE.MeshLambertMaterial({ color: 0x00A000 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            water: new THREE.MeshLambertMaterial({ color: 0x00BFFF, transparent: true, opacity: 0.8 }),
        };

        const keyStates = {};
        let mousePosition = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let intersectedObject;

        // Helper function to show a temporary message
        function showMessage(text) {
            statusMessage.textContent = text;
            statusMessage.style.opacity = 1;
            clearTimeout(statusMessage.timeout);
            statusMessage.timeout = setTimeout(() => {
                statusMessage.style.opacity = 0;
            }, 2000);
        }

        // Helper function to create a block mesh
        function createBlockMesh(x, y, z, type) {
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const material = blocks[type];
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.userData.position = new THREE.Vector3(x, y, z); // Store original position
            mesh.userData.type = type; // Store block type
            return mesh;
        }

        // Generate a simple, flat world
        function generateWorld() {
            world = [];
            for (let x = 0; x < worldSize; x++) {
                world[x] = [];
                for (let y = 0; y < 1; y++) {
                    world[x][y] = [];
                    for (let z = 0; z < worldSize; z++) {
                        // Create a grass block plane
                        const block = createBlockMesh(x, y, z, 'grass');
                        scene.add(block);
                        world[x][y][z] = block;
                    }
                }
            }
        }

        // Save world data to Firestore
        async function saveWorld() {
            if (!worldDataRef) {
                showMessage("Database not available.");
                return;
            }
            try {
                const serializableWorld = world.map(row =>
                    row.map(layer =>
                        layer.map(block => ({
                            x: block.position.x,
                            y: block.position.y,
                            z: block.position.z,
                            type: block.userData.type
                        }))
                    )
                );
                await setDoc(worldDataRef, { world: JSON.stringify(serializableWorld), hunger, timestamp: new Date() });
                showMessage("World saved successfully!");
            } catch (e) {
                console.error("Error saving world: ", e);
                showMessage("Failed to save world.");
            }
        }

        // Load world data from Firestore
        async function loadWorld() {
            if (!worldDataRef) {
                showMessage("Database not available.");
                return;
            }
            try {
                const docSnap = await getDoc(worldDataRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const loadedWorld = JSON.parse(data.world);
                    hunger = data.hunger;
                    updateHungerUI();

                    // Clear existing world
                    scene.children.forEach(child => {
                        if (child.isMesh && child.userData.type) {
                            scene.remove(child);
                            child.geometry.dispose();
                            child.material.dispose();
                        }
                    });
                    world = [];
                    // Rebuild the world from loaded data
                    loadedWorld.forEach(row =>
                        row.forEach(layer =>
                            layer.forEach(blockData => {
                                const block = createBlockMesh(blockData.x, blockData.y, blockData.z, blockData.type);
                                scene.add(block);
                                if (!world[blockData.x]) world[blockData.x] = [];
                                if (!world[blockData.x][blockData.y]) world[blockData.x][blockData.y] = [];
                                world[blockData.x][blockData.y][blockData.z] = block;
                            })
                        )
                    );

                    showMessage("World loaded successfully!");
                } else {
                    showMessage("No saved world found. Starting new game.");
                    generateWorld();
                }
            } catch (e) {
                console.error("Error loading world: ", e);
                showMessage("Failed to load world.");
            }
        }

        // Set up scene, camera, and renderer
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(worldSize / 2, 2, worldSize / 2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            gameContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Add control buttons to the HUD
            const hud = document.getElementById('hud');
            const saveButton = document.createElement('button');
            saveButton.className = 'button';
            saveButton.textContent = 'Save World';
            saveButton.addEventListener('click', saveWorld);
            hud.appendChild(saveButton);

            const loadButton = document.createElement('button');
            loadButton.className = 'button';
            loadButton.textContent = 'Load World';
            loadButton.addEventListener('click', loadWorld);
            hud.appendChild(loadButton);

            // Player controls
            document.addEventListener('keydown', (event) => keyStates[event.code] = true);
            document.addEventListener('keyup', (event) => keyStates[event.code] = false);

            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === renderer.domElement) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y -= event.movementX * 0.002;
                    camera.rotation.x -= event.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });

            // Pointer lock for mouse control
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });

            // Block building/destroying
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (document.pointerLockElement !== renderer.domElement) return;

                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(scene.children);

                if (intersects.length > 0) {
                    intersectedObject = intersects[0];
                    const block = intersectedObject.object;

                    // Remove block (left click)
                    if (event.button === 0) {
                        if (block.userData.type) {
                            scene.remove(block);
                            block.geometry.dispose();
                            block.material.dispose();

                            const { x, y, z } = block.userData.position;
                            if (world[x] && world[x][y] && world[x][y][z]) {
                                world[x][y][z] = null;
                            }
                        }
                    }
                    // Place block (right click)
                    else if (event.button === 2) {
                        const normal = intersectedObject.face.normal;
                        const pos = block.position.clone().add(normal);
                        
                        const newBlock = createBlockMesh(pos.x, pos.y, pos.z, 'wood');
                        scene.add(newBlock);
                        if (!world[pos.x]) world[pos.x] = [];
                        if (!world[pos.x][pos.y]) world[pos.x][pos.y] = [];
                        world[pos.x][pos.y][pos.z] = newBlock;
                    }
                }
            });

            // Disable context menu on right click
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            // Listen for changes in Firestore to update the game state
            if (worldDataRef) {
                onSnapshot(worldDataRef, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        console.log("Real-time update from Firestore:", data);
                        // Optional: Live update the game state from this snapshot.
                        // For a single-player game, this mainly confirms the save/load mechanism.
                        // In multiplayer, this would be crucial.
                    }
                }, (error) => {
                    console.error("Error with real-time snapshot:", error);
                });
            }

            // Start the hunger drain
            hungerInterval = setInterval(drainHunger, 1000);
        }

        // Update hunger bar UI
        function updateHungerUI() {
            hungerFill.style.width = `${hunger}%`;
            if (hunger <= 25) {
                hungerFill.style.backgroundColor = 'red';
            } else if (hunger <= 50) {
                hungerFill.style.backgroundColor = 'yellow';
            } else {
                hungerFill.style.backgroundColor = 'orange';
            }
        }

        // Drain hunger over time
        function drainHunger() {
            if (hunger > 0) {
                hunger -= hungerDrainRate;
                updateHungerUI();
            } else {
                // If hunger is at 0, you could start losing health here
            }
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Player movement
            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            camera.getWorldDirection(forward);
            right.crossVectors(forward, camera.up);

            if (keyStates['KeyW']) camera.position.add(forward.multiplyScalar(playerSpeed));
            if (keyStates['KeyS']) camera.position.add(forward.multiplyScalar(-playerSpeed));
            if (keyStates['KeyA']) camera.position.add(right.multiplyScalar(-playerSpeed));
            if (keyStates['KeyD']) camera.position.add(right.multiplyScalar(playerSpeed));

            renderer.render(scene, camera);
        }

        // Start the game after all resources are loaded
        window.onload = async function() {
            // Initialize Firebase first
            await initFirebase();
            // Then initialize the game
            init();
            // Load world from database or generate new one
            await loadWorld();
            // Start the animation loop
            animate();
            // Hide loading screen
            loadingScreen.style.display = 'none';
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
